

# MVCæ¶æ„æ€æ ·çš„

# dependenciesçš„å¼•ç”¨æ˜¯æ€æ ·çš„ï¼Œ

# Google Cloud Platform


# A Algorithm (A-star):*
f(n)=g(n)+h(n)

## Greedy Best-First Search (GBFS)
a heuristic function **â„(ğ‘›) h(n)** that estimates the cost from the current node ğ‘› n to the goal
It is not guaranteed to find the shortest path, as it does not consider the cost already incurred to reach a node. It can easily get trapped in local minima.

## Dijkstra's Algorithm ï¼ˆLike BFS without weightï¼‰
always expanding the node with the lowest cumulative cost (often called cost-so-far or **g(n)**) from the start.
Dijkstraâ€™s algorithm does not use a heuristic function, and it guarantees the shortest path because it always chooses the path with the lowest actual cumulative cost.
Since Dijkstraâ€™s algorithm explores all possible paths, it can be slower than algorithms that incorporate heuristics, especially for large graphs.

## A Algorithm (A-star):
Approach: A* is a combination of Dijkstraâ€™s algorithm and Greedy Best-First Search. It uses both the actual cost to reach the current node 
ğ‘”(ğ‘›)g(n) and the heuristic estimate â„(ğ‘›)h(n) of the cost to the goal. 
**f(n)=g(n)+h(n)**


## Relationship Summary:
GBFS is purely heuristic-driven and can be fast but is not guaranteed to find the shortest path.
Dijkstra's Algorithm ignores the heuristic and always finds the shortest path but can be slow, especially in large graphs.

A* balances both strategies by using the actual cost from the start h(n), which makes it more efficient than Dijkstraâ€™s algorithm while still guaranteeing the shortest path (under an admissible heuristic).

In essence, Dijkstra's algorithm is a special case of A* where the heuristic h(n)=0, and GBFS is like A* without considering the actual cost g(n).



# Ruby


https://hutusi.com/articles/ruby-quickstart

# .NET
## .NET æ¡†æ¶ NETã€postå’ŒgetåŒºåˆ«ï¼Œï¼ˆå‰ç«¯å±•ç¤ºå¤©æ°”ï¼Œéœ€è¦é€‰æ‹©æ€æ ·çš„apiå’Œè·å–æ€æ ·çš„ç»“æœï¼‰


ASP.NETæ˜¯ç”±å¾®è½¯åœ¨. NET Frameworkæ¡†æ¶ä¸­æ‰€æä¾›ï¼Œå¼€å‘Webåº”ç”¨ç¨‹åºçš„ç±»åˆ«åº“ï¼Œå°è£…åœ¨ System.Web.dll æ–‡ä»¶ä¸­ï¼Œæ˜¾éœ²å‡º System.Web å‘½åç©ºé—´ï¼Œå¹¶æä¾›ASP.NETç½‘é¡µå¤„ç†ã€æ‰©å±•ä»¥åŠHTTPé€šé“çš„åº”ç”¨ç¨‹åºä¸é€šä¿¡å¤„ç†ç­‰å·¥ä½œï¼Œä»¥åŠWeb Serviceçš„åŸºç¡€æ¶æ„ã€‚


Getè¯·æ±‚å’ŒPostè¯·æ±‚çš„åŒºåˆ«
â€ƒâ€ƒ1. é¦–å…ˆä»å­—é¢æ„æ€ä¸Š
â€ƒâ€ƒâ€ƒGetçš„æ„æ€æ˜¯â€œå¾—åˆ°ï¼Œè·å–â€ï¼ŒPostçš„æ„æ€æ˜¯â€œæ¨é€â€ã€‚æ‰€ä»¥å¯è§å¦‚æœæ˜¯Getæ–¹å¼ï¼Œå³æµè§ˆå™¨å‘æœåŠ¡å™¨è¯·æ±‚å¾—åˆ°ä¸€äº›æ•°æ®ï¼›å¦‚æœæ˜¯Postæ–¹å¼ï¼Œå°±æ˜¯æµè§ˆå™¨ä¸»åŠ¨å‘æœåŠ¡å™¨æ¨é€æ•°æ®ã€‚

â€ƒâ€ƒ2. ä¼ é€æ•°æ®çš„æ–¹å¼ä¸åŒ
â€ƒâ€ƒâ€ƒGetæ–¹å¼ä¼šç›´æ¥å°†å‚æ•°æ”¾åœ¨URLåœ°å€çš„åé¢ï¼Œç”¨æˆ·å¯ä»¥ç›´æ¥çœ‹çš„è§ï¼Œè€Œä¸”Getæ–¹å¼ï¼Œç”±äºæµè§ˆå™¨çš„ä¸åŒï¼Œå…è®¸ä¼ é€æœ€å¤§æ•°æ®é‡çš„å¤§å°ä¹Ÿä¸åŒï¼Œä¸€èˆ¬éƒ½æ˜¯2KB
â€ƒâ€ƒâ€ƒPostæ–¹å¼ä¼ é€æ•°æ®æ—¶ï¼Œä¼šå°†æ•°æ®æ”¾åœ¨httpæŠ¥æ–‡çš„è¯·æ±‚ä½“ä¸­ï¼Œç”¨æˆ·æ˜¯çœ‹ä¸è§çš„ï¼Œè€Œä¸”ç†è®ºä¸Šä¼ é€çš„æ•°æ®é‡å¤§å°æ²¡æœ‰é™åˆ¶ã€‚
â€ƒâ€ƒâ€ƒæ‰€ä»¥ç›¸å¯¹æ¥è¯´ï¼ŒPostæ–¹å¼è¦æ¯”Getæ–¹å¼æ›´å®‰å…¨ä¸€äº›ã€‚

â€ƒâ€ƒ3. åå°æ¥æ”¶æ•°æ®çš„æ–¹å¼ä¸åŒ

      //Getæ–¹å¼
      contxt.Request.QueryString["txtname"];
      //Postæ–¹å¼
      context.Request.Form["txtname"];
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”






# Rust

# Linux


# React in JS


# SVM 
 support vector machine (SVM) is a supervised machine learning algorithm that classifies data by finding an optimal line or hyperplane that maximizes the distance between each class in an N-dimensional space.
 good for high dimension

 ## kernal function
 BMI

 # Naive bayes algorithm



# Spring for JAVA




# ä»€ä¹ˆæ˜¯threadï¼Œprocessï¼Œä»–ä»¬çš„å…³ç³»ï¼Ÿ

A thread and a process are both fundamental concepts in computer programming for handling concurrent tasks. They help improve the efficiency and execution speed of programs, but they differ in nature and how they are used.

1. Process
Definition: A process is an instance of a program running on a computer. Each process has its own memory space, data, code, and resources.
Characteristics:
Independence: A process is an independent unit, and the operating system allocates separate memory for each process. One process cannot directly access another process's memory unless they communicate through Inter-Process Communication (IPC).
Resource management: A process has its own file descriptors, stack, registers, and address space. The operating system manages resources for the process.
High overhead: Creating, destroying, or switching between processes is resource-intensive because it requires switching context (e.g., saving and restoring CPU registers, changing memory, etc.).
Example: A web browser, text editor, or any application running on your system is a process.

2. Thread
Definition: A thread is a unit of execution within a process, often referred to as a "lightweight process." A process can have multiple threads, and these threads share the process's resources.
Characteristics:
Shared memory: All threads in a process share the same memory space (like the heap and global variables), making communication between threads easier and faster compared to communication between processes.
Independent execution: Each thread has its own program counter (PC), registers, and stack, so it can run independently.
Lower overhead: Threads are less resource-intensive to create and switch between because they donâ€™t need separate memory spaces.
Concurrent execution: Multiple threads can run concurrently within the same process. For example, in a browser process, one thread might handle user input while another loads a webpage.

3. Relationship between Process and Thread
Threads belong to processes: A process can contain multiple threads, and threads cannot exist independently of a process. Each process has at least one main thread (the one that starts the process).

Shared vs. isolated memory: Threads within the same process share memory and global variables, while processes are isolated from each other and have their own memory. This makes communication between threads faster, but it also introduces challenges like thread safety (e.g., race conditions when multiple threads try to access the same resource).

Concurrency model: Processes are suited for tasks that need strong isolation because each process has its own resources and memory. Threads are better for tasks that are part of the same overall job because they share resources.

4. Summary
Process: An independent instance of a running program, with separate memory and resources.
Thread: A lightweight unit of execution within a process that shares resources with other threads in the same process.
Relationship: A thread is dependent on a process, and the process acts as a container for threads. Threads are more lightweight and suited for concurrent execution, while processes are better for tasks that require strict separation and isolation.
In short, both processes and threads enable concurrency, but they differ in terms of how they share resources and the overhead involved in managing them.







1. ä»€ä¹ˆæ˜¯threadï¼Œprocessï¼Œä»–ä»¬çš„å…³ç³»ï¼Ÿ
2. è§£é‡Šä»€ä¹ˆæ˜¯Jacobian matrix, hessian matrix
3. è§£é‡Šcap theorem
4. Mutex and semaphore è§£é‡Š
5. Unix pipe æ˜¯ä»€ä¹ˆï¼Ÿ
6. Byzantine generals problem
7. å¼ºåŒ–å­¦ä¹ ï¼Œä»€ä¹ˆæ˜¯on policy off policy, TRPO ppo æœ‰ä»€ä¹ˆåŒºåˆ«è”ç³»ï¼Œä¼˜åŠ£
8. transformer maskåŠ åœ¨ä»€ä¹ˆåœ°æ–¹ï¼Ÿ